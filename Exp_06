#include <stdio.h>
#include <math.h>

#define SIZE 8  // Number of bits

// Left shift A and Q together
void leftShift(int A[], int Q[]) {
    for (int i = 0; i < SIZE - 1; i++) {
        A[i] = A[i + 1];
    }
    A[SIZE - 1] = Q[0];

    for (int i = 0; i < SIZE - 1; i++) {
        Q[i] = Q[i + 1];
    }
    Q[SIZE - 1] = 0;
}

// Binary addition
void binaryAdd(int A[], int B[]) {
    int carry = 0;
    for (int i = SIZE - 1; i >= 0; i--) {
        int sum = A[i] + B[i] + carry;
        A[i] = sum % 2;
        carry = sum / 2;
    }
}

// Binary subtraction (A = A - B)
void binarySub(int A[], int B[]) {
    int negB[SIZE];

    // Take 1's complement of B
    for (int i = 0; i < SIZE; i++)
        negB[i] = (B[i] == 0) ? 1 : 0;

    int one[SIZE] = {0};
    one[SIZE - 1] = 1;

    // Take 2's complement of B and add to A
    binaryAdd(negB, one); // 2's complement of B
    binaryAdd(A, negB);   // A = A + (-B)
}

// Decimal to binary
void decToBin(int num, int bin[]) {
    for (int i = SIZE - 1; i >= 0; i--) {
        bin[i] = num % 2;
        num /= 2;
    }
}

// Binary to decimal (supports signed 2's complement)
int binToDec(int bin[]) {
    int num = 0;
    int isNegative = bin[0];

    if (isNegative) {
        // Take 2's complement and convert
        int temp[SIZE];
        for (int i = 0; i < SIZE; i++)
            temp[i] = (bin[i] == 0) ? 1 : 0;

        int one[SIZE] = {0};
        one[SIZE - 1] = 1;
        binaryAdd(temp, one);

        for (int i = 0; i < SIZE; i++)
            num += temp[i] * pow(2, SIZE - 1 - i);

        num = -num;
    } else {
        for (int i = 0; i < SIZE; i++)
            num += bin[i] * pow(2, SIZE - 1 - i);
    }

    return num;
}

// Print binary array with label
void printBin(char *label, int bin[]) {
    printf("%s: ", label);
    for (int i = 0; i < SIZE; i++)
        printf("%d", bin[i]);
    printf("\n");
}

int main() {
    int A[SIZE] = {0};
    int Q[SIZE];
    int M[SIZE];

    int dividend, divisor;

    printf("Enter Dividend: ");
    scanf("%d", &dividend);

    printf("Enter Divisor: ");
    scanf("%d", &divisor);

    decToBin(dividend, Q);
    decToBin(divisor, M);

    printf("\nInitial Values:\n");
    printBin("A", A);
    printBin("Q", Q);
    printBin("M", M);

    printf("\nNon-Restoring Division Steps:\n");

    for (int i = 0; i < SIZE; i++) {
        printf("\nStep %d:\n", i + 1);

        // Left shift A and Q
        leftShift(A, Q);
        printBin("After Shift A", A);
        printBin("After Shift Q", Q);

        // Check sign of A
        if (A[0] == 0) {
            binarySub(A, M); // A = A - M
            printf("A = A - M\n");
        } else {
            binaryAdd(A, M); // A = A + M
            printf("A = A + M (because A was negative)\n");
        }

        printBin("A", A);

        // Set Q0
        if (A[0] == 0)
            Q[SIZE - 1] = 1;
        else
            Q[SIZE - 1] = 0;

        printBin("Updated Q", Q);
    }

    // Final correction if A is negative
    if (A[0] == 1) {
        binaryAdd(A, M);
        printf("\nFinal Correction: A was negative, so A = A + M\n");
        printBin("Corrected A", A);
    }

    printf("\nFinal Result:\n");
    printBin("Quotient (Q)", Q);
    printBin("Remainder (A)", A);

    printf("\nDecimal Result:\n");
    printf("Quotient: %d\n", binToDec(Q));
    printf("Remainder: %d\n", binToDec(A));

    return 0;
}
